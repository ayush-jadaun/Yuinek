// ==================== FOLDER STRUCTURE ====================
/*
shoe-ecommerce/
├── src/
│   ├── app/
│   │   ├── (auth)/
│   │   │   ├── login/
│   │   │   │   └── page.tsx
│   │   │   ├── register/
│   │   │   │   └── page.tsx
│   │   │   └── layout.tsx
│   │   ├── (shop)/
│   │   │   ├── products/
│   │   │   │   ├── [slug]/
│   │   │   │   │   └── page.tsx
│   │   │   │   └── page.tsx
│   │   │   ├── categories/
│   │   │   │   ├── [slug]/
│   │   │   │   │   └── page.tsx
│   │   │   │   └── page.tsx
│   │   │   ├── cart/
│   │   │   │   └── page.tsx
│   │   │   ├── wishlist/
│   │   │   │   └── page.tsx
│   │   │   └── layout.tsx
│   │   ├── (dashboard)/
│   │   │   ├── admin/
│   │   │   │   ├── products/
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── orders/
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── users/
│   │   │   │   │   └── page.tsx
│   │   │   │   └── page.tsx
│   │   │   └── layout.tsx
│   │   ├── api/
│   │   │   ├── auth/
│   │   │   │   ├── login/
│   │   │   │   │   └── route.ts
│   │   │   │   ├── register/
│   │   │   │   │   └── route.ts
│   │   │   │   ├── refresh-token/
│   │   │   │   │   └── route.ts
│   │   │   │   └── logout/
│   │   │   │       └── route.ts
│   │   │   ├── products/
│   │   │   │   ├── route.ts
│   │   │   │   └── [id]/
│   │   │   │       └── route.ts
│   │   │   ├── categories/
│   │   │   │   └── route.ts
│   │   │   ├── orders/
│   │   │   │   └── route.ts
│   │   │   ├── cart/
│   │   │   │   └── route.ts
│   │   │   └── payments/
│   │   │       ├── stripe/
│   │   │       │   └── route.ts
│   │   │       └── webhook/
│   │   │           └── route.ts
│   │   ├── globals.css
│   │   ├── layout.tsx
│   │   ├── page.tsx
│   │   └── not-found.tsx
│   ├── components/
│   │   ├── ui/
│   │   │   ├── Button.tsx
│   │   │   ├── Input.tsx
│   │   │   ├── Modal.tsx
│   │   │   └── Card.tsx
│   │   ├── layout/
│   │   │   ├── Header.tsx
│   │   │   ├── Footer.tsx
│   │   │   └── Sidebar.tsx
│   │   ├── product/
│   │   │   ├── ProductCard.tsx
│   │   │   ├── ProductGrid.tsx
│   │   │   └── ProductDetails.tsx
│   │   └── forms/
│   │       ├── LoginForm.tsx
│   │       ├── RegisterForm.tsx
│   │       └── AddressForm.tsx
│   ├── lib/
│   │   ├── db/
│   │   │   └── mongodb.ts
│   │   ├── auth/
│   │   │   ├── jwt.ts
│   │   │   └── middleware.ts
│   │   ├── validations/
│   │   │   ├── auth.ts
│   │   │   ├── product.ts
│   │   │   └── order.ts
│   │   └── utils.ts
│   ├── models/
│   │   ├── User.ts
│   │   ├── Product.ts
│   │   ├── Category.ts
│   │   ├── Order.ts
│   │   ├── RefreshToken.ts
│   │   └── index.ts
│   ├── store/
│   │   ├── authStore.ts
│   │   ├── cartStore.ts
│   │   └── productStore.ts
│   └── types/
│       ├── auth.ts
│       ├── product.ts
│       ├── order.ts
│       └── index.ts
├── public/
│   ├── images/
│   └── icons/
├── .env.local
├── next.config.js
├── package.json
├── tailwind.config.js
└── tsconfig.json
*/

// ==================== MODELS ====================

// src/models/User.ts
import mongoose, { Schema, Document } from "mongoose";

export interface IUser extends Document {
  email: string;
  password_hash: string;
  first_name: string;
  last_name: string;
  phone?: string;
  user_type: 'customer' | 'admin' | 'staff';
  is_active: boolean;
  email_verified: boolean;
  addresses: IAddress[];
  createdAt: Date;
  updatedAt: Date;
}

export interface IAddress {
  type: 'billing' | 'shipping';
  first_name: string;
  last_name: string;
  company?: string;
  address_line_1: string;
  address_line_2?: string;
  city: string;
  state_province: string;
  postal_code: string;
  country: string;
  phone?: string;
  is_default: boolean;
}

const AddressSchema = new Schema<IAddress>({
  type: { type: String, enum: ['billing', 'shipping'], required: true },
  first_name: { type: String, required: true },
  last_name: { type: String, required: true },
  company: String,
  address_line_1: { type: String, required: true },
  address_line_2: String,
  city: { type: String, required: true },
  state_province: { type: String, required: true },
  postal_code: { type: String, required: true },
  country: { type: String, default: 'Philippines' },
  phone: String,
  is_default: { type: Boolean, default: false }
});

const UserSchema = new Schema<IUser>({
  email: { 
    type: String, 
    required: true, 
    unique: true, 
    lowercase: true, 
    trim: true 
  },
  password_hash: { type: String, required: true },
  first_name: { type: String, required: true, trim: true },
  last_name: { type: String, required: true, trim: true },
  phone: { type: String, trim: true },
  user_type: { 
    type: String, 
    enum: ['customer', 'admin', 'staff'], 
    default: 'customer' 
  },
  is_active: { type: Boolean, default: true },
  email_verified: { type: Boolean, default: false },
  addresses: [AddressSchema]
}, { 
  timestamps: true 
});

export default mongoose.models.User || mongoose.model<IUser>("User", UserSchema);

// src/models/RefreshToken.ts
import mongoose, { Schema, Document } from "mongoose";

export interface IRefreshToken extends Document {
  user_id: mongoose.Types.ObjectId;
  token_hash: string;
  device_info?: string;
  ip_address?: string;
  is_active: boolean;
  expires_at: Date;
  createdAt: Date;
}

const RefreshTokenSchema = new Schema<IRefreshToken>({
  user_id: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  token_hash: { type: String, required: true },
  device_info: String,
  ip_address: String,
  is_active: { type: Boolean, default: true },
  expires_at: { type: Date, required: true }
}, { 
  timestamps: { createdAt: true, updatedAt: false } 
});

export default mongoose.models.RefreshToken || mongoose.model<IRefreshToken>("RefreshToken", RefreshTokenSchema);

// src/models/Category.ts
import mongoose, { Schema, Document } from "mongoose";

export interface ICategory extends Document {
  name: string;
  slug: string;
  parent_id?: mongoose.Types.ObjectId;
  description?: string;
  image_url?: string;
  is_active: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const CategorySchema = new Schema<ICategory>({
  name: { type: String, required: true, trim: true },
  slug: { type: String, required: true, unique: true, lowercase: true },
  parent_id: { type: Schema.Types.ObjectId, ref: 'Category' },
  description: String,
  image_url: String,
  is_active: { type: Boolean, default: true }
}, { 
  timestamps: true 
});

export default mongoose.models.Category || mongoose.model<ICategory>("Category", CategorySchema);

// src/models/Product.ts
import mongoose, { Schema, Document } from "mongoose";

export interface IProductVariant {
  size_id: mongoose.Types.ObjectId;
  color_id: mongoose.Types.ObjectId;
  stock_quantity: number;
  price_adjustment: number;
  is_active: boolean;
}

export interface IProductImage {
  color_id?: mongoose.Types.ObjectId;
  image_url: string;
  alt_text?: string;
  is_primary: boolean;
}

export interface IProduct extends Document {
  name: string;
  product_code: number;
  category_id: mongoose.Types.ObjectId;
  description: string;
  short_description?: string;
  base_price: number;
  sale_price?: number;
  cost_price?: number;
  weight?: number;
  slug: string;
  is_featured: boolean;
  is_active: boolean;
  stock_status: 'in_stock' | 'out_of_stock' | 'pre_order';
  manage_stock: boolean;
  stock_quantity: number;
  low_stock_threshold: number;
  images: IProductImage[];
  variants: IProductVariant[];
  meta_title?: string;
  meta_description?: string;
  createdAt: Date;
  updatedAt: Date;
}

const ProductVariantSchema = new Schema<IProductVariant>({
  size_id: { type: Schema.Types.ObjectId, ref: 'Size', required: true },
  color_id: { type: Schema.Types.ObjectId, ref: 'Color', required: true },
  stock_quantity: { type: Number, required: true, min: 0 },
  price_adjustment: { type: Number, default: 0 },
  is_active: { type: Boolean, default: true }
});

const ProductImageSchema = new Schema<IProductImage>({
  color_id: { type: Schema.Types.ObjectId, ref: 'Color' },
  image_url: { type: String, required: true },
  alt_text: String,
  is_primary: { type: Boolean, default: false }
});

const ProductSchema = new Schema<IProduct>({
  name: { type: String, required: true, trim: true },
  product_code: { type: Number, required: true, unique: true },
  category_id: { type: Schema.Types.ObjectId, ref: 'Category', required: true },
  description: { type: String, required: true },
  short_description: String,
  base_price: { type: Number, required: true, min: 0 },
  sale_price: { type: Number, min: 0 },
  cost_price: { type: Number, min: 0 },
  weight: Number,
  slug: { type: String, required: true, unique: true, lowercase: true },
  is_featured: { type: Boolean, default: false },
  is_active: { type: Boolean, default: true },
  stock_status: { 
    type: String, 
    enum: ['in_stock', 'out_of_stock', 'pre_order'], 
    default: 'in_stock' 
  },
  manage_stock: { type: Boolean, default: true },
  stock_quantity: { type: Number, default: 0, min: 0 },
  low_stock_threshold: { type: Number, default: 5 },
  images: [ProductImageSchema],
  variants: [ProductVariantSchema],
  meta_title: String,
  meta_description: String
}, { 
  timestamps: true 
});

export default mongoose.models.Product || mongoose.model<IProduct>("Product", ProductSchema);

// src/models/Size.ts
import mongoose, { Schema, Document } from "mongoose";

export interface ISize extends Document {
  us_size: string;
  eu_size?: string;
  uk_size?: string;
  cm_size?: number;
  gender: 'men' | 'women' | 'kids';
  createdAt: Date;
}

const SizeSchema = new Schema<ISize>({
  us_size: { type: String, required: true },
  eu_size: String,
  uk_size: String,
  cm_size: Number,
  gender: { type: String, enum: ['men', 'women', 'kids'], required: true }
}, { 
  timestamps: { createdAt: true, updatedAt: false } 
});

export default mongoose.models.Size || mongoose.model<ISize>("Size", SizeSchema);

// src/models/Color.ts
import mongoose, { Schema, Document } from "mongoose";

export interface IColor extends Document {
  name: string;
  hex_code?: string;
  createdAt: Date;
}

const ColorSchema = new Schema<IColor>({
  name: { type: String, required: true, trim: true },
  hex_code: { 
    type: String, 
    match: /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/ 
  }
}, { 
  timestamps: { createdAt: true, updatedAt: false } 
});

export default mongoose.models.Color || mongoose.model<IColor>("Color", ColorSchema);

// src/models/Order.ts
import mongoose, { Schema, Document } from "mongoose";

export interface IOrderItem {
  product_id: mongoose.Types.ObjectId;
  product_variant_id?: mongoose.Types.ObjectId;
  product_name: string;
  product_code: number;
  size_name: string;
  color_name: string;
  quantity: number;
  unit_price: number;
  total_price: number;
}

export interface IOrder extends Document {
  order_number: string;
  user_id: mongoose.Types.ObjectId;
  status: 'pending' | 'processing' | 'shipped' | 'delivered' | 'cancelled' | 'refunded';
  subtotal: number;
  tax_amount: number;
  shipping_amount: number;
  discount_amount: number;
  total_amount: number;
  currency: string;
  billing_address: object;
  shipping_address: object;
  items: IOrderItem[];
  payment_method: string;
  payment_status: 'pending' | 'paid' | 'failed' | 'refunded' | 'partially_refunded';
  notes?: string;
  createdAt: Date;
  updatedAt: Date;
}

const OrderItemSchema = new Schema<IOrderItem>({
  product_id: { type: Schema.Types.ObjectId, ref: 'Product', required: true },
  product_variant_id: { type: Schema.Types.ObjectId },
  product_name: { type: String, required: true },
  product_code: { type: Number, required: true },
  size_name: { type: String, required: true },
  color_name: { type: String, required: true },
  quantity: { type: Number, required: true, min: 1 },
  unit_price: { type: Number, required: true, min: 0 },
  total_price: { type: Number, required: true, min: 0 }
});

const OrderSchema = new Schema<IOrder>({
  order_number: { type: String, required: true, unique: true },
  user_id: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  status: { 
    type: String, 
    enum: ['pending', 'processing', 'shipped', 'delivered', 'cancelled', 'refunded'],
    default: 'pending'
  },
  subtotal: { type: Number, required: true, min: 0 },
  tax_amount: { type: Number, default: 0, min: 0 },
  shipping_amount: { type: Number, default: 0, min: 0 },
  discount_amount: { type: Number, default: 0, min: 0 },
  total_amount: { type: Number, required: true, min: 0 },
  currency: { type: String, default: 'PHP' },
  billing_address: { type: Schema.Types.Mixed, required: true },
  shipping_address: { type: Schema.Types.Mixed, required: true },
  items: [OrderItemSchema],
  payment_method: { type: String, required: true },
  payment_status: { 
    type: String, 
    enum: ['pending', 'paid', 'failed', 'refunded', 'partially_refunded'],
    default: 'pending'
  },
  notes: String
}, { 
  timestamps: true 
});

export default mongoose.models.Order || mongoose.model<IOrder>("Order", OrderSchema);

// ==================== DATABASE CONNECTION ====================

// src/lib/db/mongodb.ts
import mongoose from 'mongoose';

const MONGODB_URI = process.env.MONGODB_URI!;

if (!MONGODB_URI) {
  throw new Error('Please define the MONGODB_URI environment variable');
}

interface MongooseCache {
  conn: typeof mongoose | null;
  promise: Promise<typeof mongoose> | null;
}

declare global {
  var mongoose: MongooseCache | undefined;
}

let cached: MongooseCache = global.mongoose || { conn: null, promise: null };

if (!global.mongoose) {
  global.mongoose = cached;
}

export async function connectDB(): Promise<typeof mongoose> {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts);
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

// ==================== JWT UTILITIES ====================

// src/lib/auth/jwt.ts
import jwt from 'jsonwebtoken';
import crypto from 'crypto';

const JWT_SECRET = process.env.JWT_SECRET!;
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET!;

export interface JWTPayload {
  userId: string;
  email: string;
  userType: string;
}

export function generateAccessToken(payload: JWTPayload): string {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: '15m' });
}

export function generateRefreshToken(payload: JWTPayload): string {
  return jwt.sign(payload, JWT_REFRESH_SECRET, { expiresIn: '7d' });
}

export function verifyAccessToken(token: string): JWTPayload | null {
  try {
    return jwt.verify(token, JWT_SECRET) as JWTPayload;
  } catch {
    return null;
  }
}

export function verifyRefreshToken(token: string): JWTPayload | null {
  try {
    return jwt.verify(token, JWT_REFRESH_SECRET) as JWTPayload;
  } catch {
    return null;
  }
}

export function hashToken(token: string): string {
  return crypto.createHash('sha256').update(token).digest('hex');
}

// ==================== API ROUTES ====================

// src/app/api/auth/register/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bcrypt from 'bcryptjs';
import { connectDB } from '@/lib/db/mongodb';
import User from '@/models/User';

export async function POST(request: NextRequest) {
  try {
    await connectDB();
    
    const { email, password, first_name, last_name, phone } = await request.json();

    // Check if user exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return NextResponse.json(
        { error: 'User already exists' },
        { status: 400 }
      );
    }

    // Hash password
    const password_hash = await bcrypt.hash(password, 12);

    // Create user
    const user = await User.create({
      email,
      password_hash,
      first_name,
      last_name,
      phone,
      user_type: 'customer'
    });

    return NextResponse.json(
      { 
        message: 'User created successfully',
        user: {
          id: user._id,
          email: user.email,
          first_name: user.first_name,
          last_name: user.last_name
        }
      },
      { status: 201 }
    );

  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// src/app/api/auth/login/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bcrypt from 'bcryptjs';
import { connectDB } from '@/lib/db/mongodb';
import User from '@/models/User';
import RefreshToken from '@/models/RefreshToken';
import { generateAccessToken, generateRefreshToken, hashToken } from '@/lib/auth/jwt';

export async function POST(request: NextRequest) {
  try {
    await connectDB();
    
    const { email, password } = await request.json();

    // Find user
    const user = await User.findOne({ email, is_active: true });
    if (!user) {
      return NextResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      );
    }

    // Verify password
    const isValidPassword = await bcrypt.compare(password, user.password_hash);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      );
    }

    // Generate tokens
    const payload = {
      userId: user._id.toString(),
      email: user.email,
      userType: user.user_type
    };

    const accessToken = generateAccessToken(payload);
    const refreshToken = generateRefreshToken(payload);

    // Store refresh token
    await RefreshToken.create({
      user_id: user._id,
      token_hash: hashToken(refreshToken),
      device_info: request.headers.get('user-agent'),
      ip_address: request.ip,
      expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
    });

    // Set cookies
    const response = NextResponse.json({
      message: 'Login successful',
      user: {
        id: user._id,
        email: user.email,
        first_name: user.first_name,
        last_name: user.last_name,
        user_type: user.user_type
      }
    });

    response.cookies.set('accessToken', accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 15 * 60 // 15 minutes
    });

    response.cookies.set('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 // 7 days
    });

    return response;

  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// ==================== PACKAGE.JSON ====================

/*
{
  "name": "shoe-ecommerce",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.0.0",
    "react": "^18",
    "react-dom": "^18",
    "mongoose": "^8.0.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "@types/bcryptjs": "^2.4.6",
    "@types/jsonwebtoken": "^9.0.5",
    "zustand": "^4.4.0",
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.0.1",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "eslint": "^8",
    "eslint-config-next": "14.0.0"
  }
}
*/

// ==================== ENVIRONMENT VARIABLES ====================

/*
// .env.local
MONGODB_URI=mongodb://localhost:27017/shoe-ecommerce
JWT_SECRET=your-super-secret-jwt-key-here-make-it-long-and-random
JWT_REFRESH_SECRET=your-super-secret-refresh-key-here-different-from-jwt
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=your-nextauth-secret-here
*/

// src/app/api/products/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { connectDB } from '@/lib/db/mongodb';
import Product from '@/models/Product';
import Category from '@/models/Category';
import Size from '@/models/Size';
import Color from '@/models/Color';

export async function GET(request: NextRequest) {
  try {
    await connectDB();
    
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '12');
    const category = searchParams.get('category');
    const search = searchParams.get('search');
    const minPrice = searchParams.get('minPrice');
    const maxPrice = searchParams.get('maxPrice');
    const featured = searchParams.get('featured');
    const sortBy = searchParams.get('sortBy') || 'createdAt';
    const sortOrder = searchParams.get('sortOrder') || 'desc';

    // Build query
    let query: any = { is_active: true };
    
    if (category) {
      const categoryDoc = await Category.findOne({ slug: category });
      if (categoryDoc) {
        query.category_id = categoryDoc._id;
      }
    }
    
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } }
      ];
    }
    
    if (minPrice || maxPrice) {
      query.base_price = {};
      if (minPrice) query.base_price.$gte = parseFloat(minPrice);
      if (maxPrice) query.base_price.$lte = parseFloat(maxPrice);
    }
    
    if (featured === 'true') {
      query.is_featured = true;
    }

    // Calculate pagination
    const skip = (page - 1) * limit;
    
    // Build sort object
    const sort: any = {};
    sort[sortBy] = sortOrder === 'desc' ? -1 : 1;

    // Execute query
    const products = await Product.find(query)
      .populate('category_id', 'name slug')
      .sort(sort)
      .skip(skip)
      .limit(limit)
      .lean();

    const total = await Product.countDocuments(query);
    const totalPages = Math.ceil(total / limit);

    return NextResponse.json({
      products,
      pagination: {
        currentPage: page,
        totalPages,
        totalProducts: total,
        hasNextPage: page < totalPages,
        hasPrevPage: page > 1
      }
    });

  } catch (error) {
    console.error('Products GET error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch products' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    await connectDB();
    
    const data = await request.json();
    
    // Generate unique product code
    const lastProduct = await Product.findOne().sort({ product_code: -1 });
    const productCode = lastProduct ? lastProduct.product_code + 1 : 1000;
    
    // Create slug from name
    const slug = data.name.toLowerCase()
      .replace(/[^a-z0-9 -]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-');
    
    const product = await Product.create({
      ...data,
      product_code: productCode,
      slug: `${slug}-${productCode}`
    });

    const populatedProduct = await Product.findById(product._id)
      .populate('category_id', 'name slug');

    return NextResponse.json(
      { 
        message: 'Product created successfully',
        product: populatedProduct
      },
      { status: 201 }
    );

  } catch (error) {
    console.error('Products POST error:', error);
    return NextResponse.json(
      { error: 'Failed to create product' },
      { status: 500 }
    );
  }
}

// src/app/api/products/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { connectDB } from '@/lib/db/mongodb';
import Product from '@/models/Product';
import mongoose from 'mongoose';

interface Params {
  id: string;
}

export async function GET(
  request: NextRequest,
  { params }: { params: Params }
) {
  try {
    await connectDB();
    
    const { id } = params;
    
    // Check if it's a valid ObjectId or slug
    let product;
    if (mongoose.Types.ObjectId.isValid(id)) {
      product = await Product.findById(id);
    } else {
      product = await Product.findOne({ slug: id });
    }
    
    if (!product || !product.is_active) {
      return NextResponse.json(
        { error: 'Product not found' },
        { status: 404 }
      );
    }

    // Populate related data
    const populatedProduct = await Product.findById(product._id)
      .populate('category_id', 'name slug')
      .populate('variants.size_id', 'us_size eu_size uk_size cm_size gender')
      .populate('variants.color_id', 'name hex_code');

    return NextResponse.json({ product: populatedProduct });

  } catch (error) {
    console.error('Product GET error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch product' },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: Params }
) {
  try {
    await connectDB();
    
    const { id } = params;
    const data = await request.json();
    
    const product = await Product.findByIdAndUpdate(
      id,
      { ...data, updatedAt: new Date() },
      { new: true, runValidators: true }
    ).populate('category_id', 'name slug');

    if (!product) {
      return NextResponse.json(
        { error: 'Product not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      message: 'Product updated successfully',
      product
    });

  } catch (error) {
    console.error('Product PUT error:', error);
    return NextResponse.json(
      { error: 'Failed to update product' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Params }
) {
  try {
    await connectDB();
    
    const { id } = params;
    
    // Soft delete - set is_active to false
    const product = await Product.findByIdAndUpdate(
      id,
      { is_active: false, updatedAt: new Date() },
      { new: true }
    );

    if (!product) {
      return NextResponse.json(
        { error: 'Product not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      message: 'Product deleted successfully'
    });

  } catch (error) {
    console.error('Product DELETE error:', error);
    return NextResponse.json(
      { error: 'Failed to delete product' },
      { status: 500 }
    );
  }
}

// src/app/api/categories/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { connectDB } from '@/lib/db/mongodb';
import Category from '@/models/Category';

export async function GET(request: NextRequest) {
  try {
    await connectDB();
    
    const { searchParams } = new URL(request.url);
    const includeInactive = searchParams.get('includeInactive') === 'true';
    const parentId = searchParams.get('parentId');
    
    let query: any = {};
    
    if (!includeInactive) {
      query.is_active = true;
    }
    
    if (parentId) {
      query.parent_id = parentId === 'null' ? null : parentId;
    }

    const categories = await Category.find(query)
      .populate('parent_id', 'name slug')
      .sort({ name: 1 })
      .lean();

    return NextResponse.json({ categories });

  } catch (error) {
    console.error('Categories GET error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch categories' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    await connectDB();
    
    const data = await request.json();
    
    // Create slug from name
    const slug = data.name.toLowerCase()
      .replace(/[^a-z0-9 -]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-');
    
    const category = await Category.create({
      ...data,
      slug
    });

    const populatedCategory = await Category.findById(category._id)
      .populate('parent_id', 'name slug');

    return NextResponse.json(
      { 
        message: 'Category created successfully',
        category: populatedCategory
      },
      { status: 201 }
    );

  } catch (error) {
    console.error('Categories POST error:', error);
    return NextResponse.json(
      { error: 'Failed to create category' },
      { status: 500 }
    );
  }
}

// src/app/api/cart/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { connectDB } from '@/lib/db/mongodb';
import { verifyAccessToken } from '@/lib/auth/jwt';
import Product from '@/models/Product';
import mongoose from 'mongoose';

interface CartItem {
  product_id: string;
  variant_id?: string;
  size_id: string;
  color_id: string;
  quantity: number;
}

interface CartData {
  items: CartItem[];
}

export async function GET(request: NextRequest) {
  try {
    const token = request.cookies.get('accessToken')?.value;
    
    if (!token) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    const payload = verifyAccessToken(token);
    if (!payload) {
      return NextResponse.json(
        { error: 'Invalid token' },
        { status: 401 }
      );
    }

    // For this example, we'll use session storage or cookies for cart
    // In production, you might want to store cart in database for logged-in users
    const cartData = request.cookies.get('cart')?.value;
    
    if (!cartData) {
      return NextResponse.json({ cart: { items: [], total: 0 } });
    }

    const cart: CartData = JSON.parse(cartData);
    
    await connectDB();
    
    // Populate cart items with product details
    const populatedItems = await Promise.all(
      cart.items.map(async (item: CartItem) => {
        const product = await Product.findById(item.product_id)
          .populate('variants.size_id', 'us_size eu_size uk_size')
          .populate('variants.color_id', 'name hex_code');
        
        if (!product) return null;
        
        // Find the specific variant
        const variant = product.variants.find((v: any) => 
          v.size_id._id.toString() === item.size_id && 
          v.color_id._id.toString() === item.color_id
        );
        
        const price = product.sale_price || product.base_price;
        const adjustedPrice = variant ? price + variant.price_adjustment : price;
        
        return {
          ...item,
          product: {
            _id: product._id,
            name: product.name,
            slug: product.slug,
            images: product.images,
            base_price: product.base_price,
            sale_price: product.sale_price
          },
          variant,
          unit_price: adjustedPrice,
          total_price: adjustedPrice * item.quantity
        };
      })
    );

    const validItems = populatedItems.filter(item => item !== null);
    const total = validItems.reduce((sum, item) => sum + item.total_price, 0);

    return NextResponse.json({
      cart: {
        items: validItems,
        total,
        itemCount: validItems.reduce((sum, item) => sum + item.quantity, 0)
      }
    });

  } catch (error) {
    console.error('Cart GET error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch cart' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const token = request.cookies.get('accessToken')?.value;
    
    if (!token) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    const payload = verifyAccessToken(token);
    if (!payload) {
      return NextResponse.json(
        { error: 'Invalid token' },
        { status: 401 }
      );
    }

    const { product_id, size_id, color_id, quantity = 1 } = await request.json();

    await connectDB();

    // Verify product exists and has stock
    const product = await Product.findById(product_id);
    if (!product || !product.is_active) {
      return NextResponse.json(
        { error: 'Product not found' },
        { status: 404 }
      );
    }

    // Check variant stock
    const variant = product.variants.find((v: any) => 
      v.size_id.toString() === size_id && 
      v.color_id.toString() === color_id
    );

    if (variant && variant.stock_quantity < quantity) {
      return NextResponse.json(
        { error: 'Insufficient stock' },
        { status: 400 }
      );
    }

    // Get current cart
    const cartData = request.cookies.get('cart')?.value;
    let cart: CartData = cartData ? JSON.parse(cartData) : { items: [] };

    // Check if item already exists in cart
    const existingItemIndex = cart.items.findIndex(item => 
      item.product_id === product_id && 
      item.size_id === size_id && 
      item.color_id === color_id
    );

    if (existingItemIndex > -1) {
      // Update quantity
      cart.items[existingItemIndex].quantity += quantity;
    } else {
      // Add new item
      cart.items.push({
        product_id,
        size_id,
        color_id,
        quantity
      });
    }

    const response = NextResponse.json({
      message: 'Item added to cart successfully'
    });

    // Update cart cookie
    response.cookies.set('cart', JSON.stringify(cart), {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 30 * 24 * 60 * 60 // 30 days
    });

    return response;

  } catch (error) {
    console.error('Cart POST error:', error);
    return NextResponse.json(
      { error: 'Failed to add item to cart' },
      { status: 500 }
    );
  }
}

export async function PUT(request: NextRequest) {
  try {
    const token = request.cookies.get('accessToken')?.value;
    
    if (!token) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    const payload = verifyAccessToken(token);
    if (!payload) {
      return NextResponse.json(
        { error: 'Invalid token' },
        { status: 401 }
      );
    }

    const { product_id, size_id, color_id, quantity } = await request.json();

    if (quantity <= 0) {
      return NextResponse.json(
        { error: 'Quantity must be greater than 0' },
        { status: 400 }
      );
    }

    // Get current cart
    const cartData = request.cookies.get('cart')?.value;
    if (!cartData) {
      return NextResponse.json(
        { error: 'Cart is empty' },
        { status: 404 }
      );
    }

    let cart: CartData = JSON.parse(cartData);

    // Find and update item
    const itemIndex = cart.items.findIndex(item => 
      item.product_id === product_id && 
      item.size_id === size_id && 
      item.color_id === color_id
    );

    if (itemIndex === -1) {
      return NextResponse.json(
        { error: 'Item not found in cart' },
        { status: 404 }
      );
    }

    cart.items[itemIndex].quantity = quantity;

    const response = NextResponse.json({
      message: 'Cart updated successfully'
    });

    response.cookies.set('cart', JSON.stringify(cart), {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 30 * 24 * 60 * 60
    });

    return response;

  } catch (error) {
    console.error('Cart PUT error:', error);
    return NextResponse.json(
      { error: 'Failed to update cart' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const token = request.cookies.get('accessToken')?.value;
    
    if (!token) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    const payload = verifyAccessToken(token);
    if (!payload) {
      return NextResponse.json(
        { error: 'Invalid token' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const product_id = searchParams.get('product_id');
    const size_id = searchParams.get('size_id');
    const color_id = searchParams.get('color_id');

    // Get current cart
    const cartData = request.cookies.get('cart')?.value;
    if (!cartData) {
      return NextResponse.json(
        { error: 'Cart is empty' },
        { status: 404 }
      );
    }

    let cart: CartData = JSON.parse(cartData);

    if (product_id && size_id && color_id) {
      // Remove specific item
      cart.items = cart.items.filter(item => 
        !(item.product_id === product_id && 
          item.size_id === size_id && 
          item.color_id === color_id)
      );
    } else {
      // Clear entire cart
      cart.items = [];
    }

    const response = NextResponse.json({
      message: 'Item removed from cart successfully'
    });

    response.cookies.set('cart', JSON.stringify(cart), {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 30 * 24 * 60 * 60
    });

    return response;

  } catch (error) {
    console.error('Cart DELETE error:', error);
    return NextResponse.json(
      { error: 'Failed to remove item from cart' },
      { status: 500 }
    );
  }
}